{"ast":null,"code":"import { clone } from '../../../utils/object.js';\nexport function createComplexEigs(_ref) {\n  var {\n    addScalar,\n    subtract,\n    flatten,\n    multiply,\n    multiplyScalar,\n    divideScalar,\n    sqrt,\n    abs,\n    bignumber,\n    diag,\n    inv,\n    qr,\n    usolve,\n    usolveAll,\n    equal,\n    complex,\n    larger,\n    smaller,\n    matrixFromColumns,\n    dot\n  } = _ref;\n  /**\r\n   * @param {number[][]} arr the matrix to find eigenvalues of\r\n   * @param {number} N size of the matrix\r\n   * @param {number|BigNumber} prec precision, anything lower will be considered zero\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @param {boolean} findVectors should we find eigenvectors?\r\n   *\r\n   * @returns {{ values: number[], vectors: number[][] }}\r\n   */\n  function complexEigs(arr, N, prec, type, findVectors) {\n    if (findVectors === undefined) {\n      findVectors = true;\n    }\n\n    // TODO check if any row/col are zero except the diagonal\n\n    // make sure corresponding rows and columns have similar magnitude\n    // important because of numerical stability\n    // MODIFIES arr by side effect!\n    var R = balance(arr, N, prec, type, findVectors);\n\n    // R is the row transformation matrix\n    // arr = A' = R A R⁻¹, A is the original matrix\n    // (if findVectors is false, R is undefined)\n    // (And so to return to original matrix: A = R⁻¹ arr R)\n\n    // TODO if magnitudes of elements vary over many orders,\n    // move greatest elements to the top left corner\n\n    // using similarity transformations, reduce the matrix\n    // to Hessenberg form (upper triangular plus one subdiagonal row)\n    // updates the transformation matrix R with new row operationsq\n    // MODIFIES arr by side effect!\n    reduceToHessenberg(arr, N, prec, type, findVectors, R);\n    // still true that original A = R⁻¹ arr R)\n\n    // find eigenvalues\n    var {\n      values,\n      C\n    } = iterateUntilTriangular(arr, N, prec, type, findVectors);\n\n    // values is the list of eigenvalues, C is the column\n    // transformation matrix that transforms arr, the hessenberg\n    // matrix, to upper triangular\n    // (So U = C⁻¹ arr C and the relationship between current arr\n    // and original A is unchanged.)\n\n    var vectors;\n    if (findVectors) {\n      vectors = findEigenvectors(arr, N, C, R, values, prec, type);\n      vectors = matrixFromColumns(...vectors);\n    }\n    return {\n      values,\n      vectors\n    };\n  }\n\n  /**\r\n   * @param {number[][]} arr\r\n   * @param {number} N\r\n   * @param {number} prec\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @returns {number[][]}\r\n   */\n  function balance(arr, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var realzero = big ? bignumber(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    var realone = big ? bignumber(1) : 1;\n\n    // base of the floating-point arithmetic\n    var radix = big ? bignumber(10) : 2;\n    var radixSq = multiplyScalar(radix, radix);\n\n    // the diagonal transformation matrix R\n    var Rdiag;\n    if (findVectors) {\n      Rdiag = Array(N).fill(one);\n    }\n\n    // this isn't the only time we loop thru the matrix...\n    var last = false;\n    while (!last) {\n      // ...haha I'm joking! unless...\n      last = true;\n      for (var i = 0; i < N; i++) {\n        // compute the taxicab norm of i-th column and row\n        // TODO optimize for complex numbers\n        var colNorm = realzero;\n        var rowNorm = realzero;\n        for (var j = 0; j < N; j++) {\n          if (i === j) continue;\n          var c = abs(arr[i][j]); // should be real\n          colNorm = addScalar(colNorm, c);\n          rowNorm = addScalar(rowNorm, c);\n        }\n        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {\n          // find integer power closest to balancing the matrix\n          // (we want to scale only by integer powers of radix,\n          // so that we don't lose any precision due to round-off)\n\n          var f = realone;\n          var _c = colNorm;\n          var rowDivRadix = divideScalar(rowNorm, radix);\n          var rowMulRadix = multiplyScalar(rowNorm, radix);\n          while (smaller(_c, rowDivRadix)) {\n            _c = multiplyScalar(_c, radixSq);\n            f = multiplyScalar(f, radix);\n          }\n          while (larger(_c, rowMulRadix)) {\n            _c = divideScalar(_c, radixSq);\n            f = divideScalar(f, radix);\n          }\n\n          // check whether balancing is needed\n          // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)\n          var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95));\n\n          // apply balancing similarity transformation\n          if (condition) {\n            // we should loop once again to check whether\n            // another rebalancing is needed\n            last = false;\n            var g = divideScalar(1, f);\n            for (var _j = 0; _j < N; _j++) {\n              if (i === _j) {\n                continue;\n              }\n              arr[i][_j] = multiplyScalar(arr[i][_j], f);\n              arr[_j][i] = multiplyScalar(arr[_j][i], g);\n            }\n\n            // keep track of transformations\n            if (findVectors) {\n              Rdiag[i] = multiplyScalar(Rdiag[i], f);\n            }\n          }\n        }\n      }\n    }\n\n    // return the diagonal row transformation matrix\n    return diag(Rdiag);\n  }\n\n  /**\r\n   * @param {number[][]} arr\r\n   * @param {number} N\r\n   * @param {number} prec\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @param {boolean} findVectors\r\n   * @param {number[][]} R the row transformation matrix that will be modified\r\n   */\n  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    if (big) {\n      prec = bignumber(prec);\n    }\n    for (var i = 0; i < N - 2; i++) {\n      // Find the largest subdiag element in the i-th col\n\n      var maxIndex = 0;\n      var max = zero;\n      for (var j = i + 1; j < N; j++) {\n        var el = arr[j][i];\n        if (smaller(abs(max), abs(el))) {\n          max = el;\n          maxIndex = j;\n        }\n      }\n\n      // This col is pivoted, no need to do anything\n      if (smaller(abs(max), prec)) {\n        continue;\n      }\n      if (maxIndex !== i + 1) {\n        // Interchange maxIndex-th and (i+1)-th row\n        var tmp1 = arr[maxIndex];\n        arr[maxIndex] = arr[i + 1];\n        arr[i + 1] = tmp1;\n\n        // Interchange maxIndex-th and (i+1)-th column\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          var tmp2 = arr[_j2][maxIndex];\n          arr[_j2][maxIndex] = arr[_j2][i + 1];\n          arr[_j2][i + 1] = tmp2;\n        }\n\n        // keep track of transformations\n        if (findVectors) {\n          var tmp3 = R[maxIndex];\n          R[maxIndex] = R[i + 1];\n          R[i + 1] = tmp3;\n        }\n      }\n\n      // Reduce following rows and columns\n      for (var _j3 = i + 2; _j3 < N; _j3++) {\n        var n = divideScalar(arr[_j3][i], max);\n        if (n === 0) {\n          continue;\n        }\n\n        // from j-th row subtract n-times (i+1)th row\n        for (var k = 0; k < N; k++) {\n          arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));\n        }\n\n        // to (i+1)th column add n-times j-th column\n        for (var _k = 0; _k < N; _k++) {\n          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));\n        }\n\n        // keep track of transformations\n        if (findVectors) {\n          for (var _k2 = 0; _k2 < N; _k2++) {\n            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));\n          }\n        }\n      }\n    }\n    return R;\n  }\n\n  /**\r\n   * @returns {{values: values, C: Matrix}}\r\n   * @see Press, Wiliams: Numerical recipes in Fortran 77\r\n   * @see https://en.wikipedia.org/wiki/QR_algorithm\r\n   */\n  function iterateUntilTriangular(A, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    if (big) {\n      prec = bignumber(prec);\n    }\n\n    // The Francis Algorithm\n    // The core idea of this algorithm is that doing successive\n    // A' = Q⁺AQ transformations will eventually converge to block-\n    // upper-triangular with diagonal blocks either 1x1 or 2x2.\n    // The Q here is the one from the QR decomposition, A = QR.\n    // Since the eigenvalues of a block-upper-triangular matrix are\n    // the eigenvalues of its diagonal blocks and we know how to find\n    // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.\n\n    var arr = clone(A);\n\n    // the list of converged eigenvalues\n    var lambdas = [];\n\n    // size of arr, which will get smaller as eigenvalues converge\n    var n = N;\n\n    // the diagonal of the block-diagonal matrix that turns\n    // converged 2x2 matrices into upper triangular matrices\n    var Sdiag = [];\n\n    // N×N matrix describing the overall transformation done during the QR algorithm\n    var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined;\n\n    // n×n matrix describing the QR transformations done since last convergence\n    var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined;\n\n    // last eigenvalue converged before this many steps\n    var lastConvergenceBefore = 0;\n    while (lastConvergenceBefore <= 100) {\n      lastConvergenceBefore += 1;\n\n      // TODO if the convergence is slow, do something clever\n\n      // Perform the factorization\n\n      var k = 0; // TODO set close to an eigenvalue\n\n      for (var i = 0; i < n; i++) {\n        arr[i][i] = subtract(arr[i][i], k);\n      }\n\n      // TODO do an implicit QR transformation\n      var {\n        Q,\n        R\n      } = qr(arr);\n      arr = multiply(R, Q);\n      for (var _i = 0; _i < n; _i++) {\n        arr[_i][_i] = addScalar(arr[_i][_i], k);\n      }\n\n      // keep track of transformations\n      if (findVectors) {\n        Qpartial = multiply(Qpartial, Q);\n      }\n\n      // The rightmost diagonal element converged to an eigenvalue\n      if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {\n        lastConvergenceBefore = 0;\n        lambdas.push(arr[n - 1][n - 1]);\n\n        // keep track of transformations\n        if (findVectors) {\n          Sdiag.unshift([[1]]);\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 1) {\n            Qpartial = diag(Array(n - 1).fill(one));\n          }\n        }\n\n        // reduce the matrix size\n        n -= 1;\n        arr.pop();\n        for (var _i2 = 0; _i2 < n; _i2++) {\n          arr[_i2].pop();\n        }\n\n        // The rightmost diagonal 2x2 block converged\n      } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {\n        lastConvergenceBefore = 0;\n        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);\n        lambdas.push(...ll);\n\n        // keep track of transformations\n        if (findVectors) {\n          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 2) {\n            Qpartial = diag(Array(n - 2).fill(one));\n          }\n        }\n\n        // reduce the matrix size\n        n -= 2;\n        arr.pop();\n        arr.pop();\n        for (var _i3 = 0; _i3 < n; _i3++) {\n          arr[_i3].pop();\n          arr[_i3].pop();\n        }\n      }\n      if (n === 0) {\n        break;\n      }\n    }\n\n    // standard sorting\n    lambdas.sort((a, b) => +subtract(abs(a), abs(b)));\n\n    // the algorithm didn't converge\n    if (lastConvergenceBefore > 100) {\n      var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));\n      err.values = lambdas;\n      err.vectors = [];\n      throw err;\n    }\n\n    // combine the overall QR transformation Qtotal with the subsequent\n    // transformation S that turns the diagonal 2x2 blocks to upper triangular\n    var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;\n    return {\n      values: lambdas,\n      C\n    };\n  }\n\n  /**\r\n   * @param {Matrix} A hessenberg-form matrix\r\n   * @param {number} N size of A\r\n   * @param {Matrix} C column transformation matrix that turns A into upper triangular\r\n   * @param {Matrix} R similarity that turns original matrix into A\r\n   * @param {number[]} values array of eigenvalues of A\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @returns {number[][]} eigenvalues\r\n   */\n  function findEigenvectors(A, N, C, R, values, prec, type) {\n    var Cinv = inv(C);\n    var U = multiply(Cinv, A, C);\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    // turn values into a kind of \"multiset\"\n    // this way it is easier to find eigenvectors\n    var uniqueValues = [];\n    var multiplicities = [];\n    for (var λ of values) {\n      var i = indexOf(uniqueValues, λ, equal);\n      if (i === -1) {\n        uniqueValues.push(λ);\n        multiplicities.push(1);\n      } else {\n        multiplicities[i] += 1;\n      }\n    }\n\n    // find eigenvectors by solving U − λE = 0\n    // TODO replace with an iterative eigenvector algorithm\n    // (this one might fail for imprecise eigenvalues)\n\n    var vectors = [];\n    var len = uniqueValues.length;\n    var b = Array(N).fill(zero);\n    var E = diag(Array(N).fill(one));\n\n    // eigenvalues for which usolve failed (due to numerical error)\n    var failedLambdas = [];\n    var _loop = function _loop() {\n      var λ = uniqueValues[_i4];\n      var S = subtract(U, multiply(λ, E)); // the characteristic matrix\n\n      var solutions = usolveAll(S, b);\n      solutions.shift(); // ignore the null vector\n\n      // looks like we missed something, try inverse iteration\n      while (solutions.length < multiplicities[_i4]) {\n        var approxVec = inverseIterate(S, N, solutions, prec, type);\n        if (approxVec == null) {\n          // no more vectors were found\n          failedLambdas.push(λ);\n          break;\n        }\n        solutions.push(approxVec);\n      }\n\n      // Transform back into original array coordinates\n      var correction = multiply(inv(R), C);\n      solutions = solutions.map(v => multiply(correction, v));\n      vectors.push(...solutions.map(v => flatten(v)));\n    };\n    for (var _i4 = 0; _i4 < len; _i4++) {\n      _loop();\n    }\n    if (failedLambdas.length !== 0) {\n      var err = new Error('Failed to find eigenvectors for the following eigenvalues: ' + failedLambdas.join(', '));\n      err.values = values;\n      err.vectors = vectors;\n      throw err;\n    }\n    return vectors;\n  }\n\n  /**\r\n   * Compute the eigenvalues of an 2x2 matrix\r\n   * @return {[number,number]}\r\n   */\n  function eigenvalues2x2(a, b, c, d) {\n    // λ± = ½ trA ± ½ √( tr²A - 4 detA )\n    var trA = addScalar(a, d);\n    var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));\n    var x = multiplyScalar(trA, 0.5);\n    var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);\n    return [addScalar(x, y), subtract(x, y)];\n  }\n\n  /**\r\n   * For an 2x2 matrix compute the transformation matrix S,\r\n   * so that SAS⁻¹ is an upper triangular matrix\r\n   * @return {[[number,number],[number,number]]}\r\n   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf\r\n   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\r\n   */\n  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    // matrix is already upper triangular\n    // return an identity matrix\n    if (smaller(abs(c), prec)) {\n      return [[one, zero], [zero, one]];\n    }\n\n    // matrix is diagonalizable\n    // return its eigenvectors as columns\n    if (larger(abs(subtract(l1, l2)), prec)) {\n      return [[subtract(l1, d), subtract(l2, d)], [c, c]];\n    }\n\n    // matrix is not diagonalizable\n    // compute off-diagonal elements of N = A - λI\n    // N₁₂ = 0 ⇒ S = ( N⃗₁, I⃗₁ )\n    // N₁₂ ≠ 0 ⇒ S = ( N⃗₂, I⃗₂ )\n\n    var na = subtract(a, l1);\n    var nb = subtract(b, l1);\n    var nc = subtract(c, l1);\n    var nd = subtract(d, l1);\n    if (smaller(abs(nb), prec)) {\n      return [[na, one], [nc, zero]];\n    } else {\n      return [[nb, zero], [nd, one]];\n    }\n  }\n\n  /**\r\n   * Enlarge the matrix from n×n to N×N, setting the new\r\n   * elements to 1 on diagonal and 0 elsewhere\r\n   */\n  function inflateMatrix(arr, N) {\n    // add columns\n    for (var i = 0; i < arr.length; i++) {\n      arr[i].push(...Array(N - arr[i].length).fill(0));\n    }\n\n    // add rows\n    for (var _i5 = arr.length; _i5 < N; _i5++) {\n      arr.push(Array(N).fill(0));\n      arr[_i5][_i5] = 1;\n    }\n    return arr;\n  }\n\n  /**\r\n   * Create a block-diagonal matrix with the given square matrices on the diagonal\r\n   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal\r\n   * @param {number} N the size of the resulting matrix\r\n   */\n  function blockDiag(arr, N) {\n    var M = [];\n    for (var i = 0; i < N; i++) {\n      M[i] = Array(N).fill(0);\n    }\n    var I = 0;\n    for (var sub of arr) {\n      var n = sub.length;\n      for (var _i6 = 0; _i6 < n; _i6++) {\n        for (var j = 0; j < n; j++) {\n          M[I + _i6][I + j] = sub[_i6][j];\n        }\n      }\n      I += n;\n    }\n    return M;\n  }\n\n  /**\r\n   * Finds the index of an element in an array using a custom equality function\r\n   * @template T\r\n   * @param {Array<T>} arr array in which to search\r\n   * @param {T} el the element to find\r\n   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`\r\n   * @returns {number} the index of `el`, or -1 when it's not in `arr`\r\n   */\n  function indexOf(arr, el, fn) {\n    for (var i = 0; i < arr.length; i++) {\n      if (fn(arr[i], el)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\r\n   * Provided a near-singular upper-triangular matrix A and a list of vectors,\r\n   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal\r\n   * to each vector in the list\r\n   * @template T\r\n   * @param {T[][]} A near-singular square matrix\r\n   * @param {number} N dimension\r\n   * @param {T[][]} orthog list of vectors\r\n   * @param {number} prec epsilon\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @return {T[] | null} eigenvector\r\n   *\r\n   * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration\r\n   */\n  function inverseIterate(A, N, orthog, prec, type) {\n    var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;\n    var b; // the vector\n\n    // you better choose a random vector before I count to five\n    var i = 0;\n    while (true) {\n      b = randomOrthogonalVector(N, orthog, type);\n      b = usolve(A, b);\n      if (larger(norm(b), largeNum)) {\n        break;\n      }\n      if (++i >= 5) {\n        return null;\n      }\n    }\n\n    // you better converge before I count to ten\n    i = 0;\n    while (true) {\n      var c = usolve(A, b);\n      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {\n        break;\n      }\n      if (++i >= 10) {\n        return null;\n      }\n      b = normalize(c);\n    }\n    return b;\n  }\n\n  /**\r\n   * Generates a random unit vector of dimension N, orthogonal to each vector in the list\r\n   * @template T\r\n   * @param {number} N dimension\r\n   * @param {T[][]} orthog list of vectors\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @returns {T[]} random vector\r\n   */\n  function randomOrthogonalVector(N, orthog, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n\n    // generate random vector with the correct type\n    var v = Array(N).fill(0).map(_ => 2 * Math.random() - 1);\n    if (big) {\n      v = v.map(n => bignumber(n));\n    }\n    if (cplx) {\n      v = v.map(n => complex(n));\n    }\n\n    // project to orthogonal complement\n    v = orthogonalComplement(v, orthog);\n\n    // normalize\n    return normalize(v, type);\n  }\n\n  /**\r\n   * Project vector v to the orthogonal complement of an array of vectors\r\n   */\n  function orthogonalComplement(v, orthog) {\n    for (var w of orthog) {\n      // v := v − (w, v)/∥w∥² w\n      v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));\n    }\n    return v;\n  }\n\n  /**\r\n   * Calculate the norm of a vector.\r\n   * We can't use math.norm because factory can't handle circular dependency.\r\n   * Seriously, I'm really fed up with factory.\r\n   */\n  function norm(v) {\n    return abs(sqrt(dot(v, v)));\n  }\n\n  /**\r\n   * Normalize a vector\r\n   * @template T\r\n   * @param {T[]} v\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @returns {T[]} normalized vec\r\n   */\n  function normalize(v, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    return multiply(divideScalar(one, norm(v)), v);\n  }\n  return complexEigs;\n}","map":{"version":3,"names":["clone","createComplexEigs","_ref","addScalar","subtract","flatten","multiply","multiplyScalar","divideScalar","sqrt","abs","bignumber","diag","inv","qr","usolve","usolveAll","equal","complex","larger","smaller","matrixFromColumns","dot","complexEigs","arr","N","prec","type","findVectors","undefined","R","balance","reduceToHessenberg","values","C","iterateUntilTriangular","vectors","findEigenvectors","big","cplx","realzero","one","realone","radix","radixSq","Rdiag","Array","fill","last","i","colNorm","rowNorm","j","c","f","_c","rowDivRadix","rowMulRadix","condition","g","_j","zero","maxIndex","max","el","tmp1","_j2","tmp2","tmp3","_j3","n","k","_k","_k2","A","lambdas","Sdiag","Qtotal","Qpartial","lastConvergenceBefore","Q","_i","push","unshift","inflateMatrix","pop","_i2","ll","eigenvalues2x2","jordanBase2x2","_i3","sort","a","b","err","Error","join","blockDiag","Cinv","U","uniqueValues","multiplicities","λ","indexOf","len","length","E","failedLambdas","_loop","_i4","S","solutions","shift","approxVec","inverseIterate","correction","map","v","d","trA","detA","x","y","l1","l2","na","nb","nc","nd","_i5","M","I","sub","_i6","fn","orthog","largeNum","randomOrthogonalVector","norm","orthogonalComplement","normalize","_","Math","random","w"],"sources":["C:/Users/Joaquin Sanchez/React/portolio new/portfolio/node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js"],"sourcesContent":["import { clone } from '../../../utils/object.js';\r\nexport function createComplexEigs(_ref) {\r\n  var {\r\n    addScalar,\r\n    subtract,\r\n    flatten,\r\n    multiply,\r\n    multiplyScalar,\r\n    divideScalar,\r\n    sqrt,\r\n    abs,\r\n    bignumber,\r\n    diag,\r\n    inv,\r\n    qr,\r\n    usolve,\r\n    usolveAll,\r\n    equal,\r\n    complex,\r\n    larger,\r\n    smaller,\r\n    matrixFromColumns,\r\n    dot\r\n  } = _ref;\r\n  /**\r\n   * @param {number[][]} arr the matrix to find eigenvalues of\r\n   * @param {number} N size of the matrix\r\n   * @param {number|BigNumber} prec precision, anything lower will be considered zero\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @param {boolean} findVectors should we find eigenvectors?\r\n   *\r\n   * @returns {{ values: number[], vectors: number[][] }}\r\n   */\r\n  function complexEigs(arr, N, prec, type, findVectors) {\r\n    if (findVectors === undefined) {\r\n      findVectors = true;\r\n    }\r\n\r\n    // TODO check if any row/col are zero except the diagonal\r\n\r\n    // make sure corresponding rows and columns have similar magnitude\r\n    // important because of numerical stability\r\n    // MODIFIES arr by side effect!\r\n    var R = balance(arr, N, prec, type, findVectors);\r\n\r\n    // R is the row transformation matrix\r\n    // arr = A' = R A R⁻¹, A is the original matrix\r\n    // (if findVectors is false, R is undefined)\r\n    // (And so to return to original matrix: A = R⁻¹ arr R)\r\n\r\n    // TODO if magnitudes of elements vary over many orders,\r\n    // move greatest elements to the top left corner\r\n\r\n    // using similarity transformations, reduce the matrix\r\n    // to Hessenberg form (upper triangular plus one subdiagonal row)\r\n    // updates the transformation matrix R with new row operationsq\r\n    // MODIFIES arr by side effect!\r\n    reduceToHessenberg(arr, N, prec, type, findVectors, R);\r\n    // still true that original A = R⁻¹ arr R)\r\n\r\n    // find eigenvalues\r\n    var {\r\n      values,\r\n      C\r\n    } = iterateUntilTriangular(arr, N, prec, type, findVectors);\r\n\r\n    // values is the list of eigenvalues, C is the column\r\n    // transformation matrix that transforms arr, the hessenberg\r\n    // matrix, to upper triangular\r\n    // (So U = C⁻¹ arr C and the relationship between current arr\r\n    // and original A is unchanged.)\r\n\r\n    var vectors;\r\n    if (findVectors) {\r\n      vectors = findEigenvectors(arr, N, C, R, values, prec, type);\r\n      vectors = matrixFromColumns(...vectors);\r\n    }\r\n    return {\r\n      values,\r\n      vectors\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @param {number[][]} arr\r\n   * @param {number} N\r\n   * @param {number} prec\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @returns {number[][]}\r\n   */\r\n  function balance(arr, N, prec, type, findVectors) {\r\n    var big = type === 'BigNumber';\r\n    var cplx = type === 'Complex';\r\n    var realzero = big ? bignumber(0) : 0;\r\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\r\n    var realone = big ? bignumber(1) : 1;\r\n\r\n    // base of the floating-point arithmetic\r\n    var radix = big ? bignumber(10) : 2;\r\n    var radixSq = multiplyScalar(radix, radix);\r\n\r\n    // the diagonal transformation matrix R\r\n    var Rdiag;\r\n    if (findVectors) {\r\n      Rdiag = Array(N).fill(one);\r\n    }\r\n\r\n    // this isn't the only time we loop thru the matrix...\r\n    var last = false;\r\n    while (!last) {\r\n      // ...haha I'm joking! unless...\r\n      last = true;\r\n      for (var i = 0; i < N; i++) {\r\n        // compute the taxicab norm of i-th column and row\r\n        // TODO optimize for complex numbers\r\n        var colNorm = realzero;\r\n        var rowNorm = realzero;\r\n        for (var j = 0; j < N; j++) {\r\n          if (i === j) continue;\r\n          var c = abs(arr[i][j]); // should be real\r\n          colNorm = addScalar(colNorm, c);\r\n          rowNorm = addScalar(rowNorm, c);\r\n        }\r\n        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {\r\n          // find integer power closest to balancing the matrix\r\n          // (we want to scale only by integer powers of radix,\r\n          // so that we don't lose any precision due to round-off)\r\n\r\n          var f = realone;\r\n          var _c = colNorm;\r\n          var rowDivRadix = divideScalar(rowNorm, radix);\r\n          var rowMulRadix = multiplyScalar(rowNorm, radix);\r\n          while (smaller(_c, rowDivRadix)) {\r\n            _c = multiplyScalar(_c, radixSq);\r\n            f = multiplyScalar(f, radix);\r\n          }\r\n          while (larger(_c, rowMulRadix)) {\r\n            _c = divideScalar(_c, radixSq);\r\n            f = divideScalar(f, radix);\r\n          }\r\n\r\n          // check whether balancing is needed\r\n          // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)\r\n          var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95));\r\n\r\n          // apply balancing similarity transformation\r\n          if (condition) {\r\n            // we should loop once again to check whether\r\n            // another rebalancing is needed\r\n            last = false;\r\n            var g = divideScalar(1, f);\r\n            for (var _j = 0; _j < N; _j++) {\r\n              if (i === _j) {\r\n                continue;\r\n              }\r\n              arr[i][_j] = multiplyScalar(arr[i][_j], f);\r\n              arr[_j][i] = multiplyScalar(arr[_j][i], g);\r\n            }\r\n\r\n            // keep track of transformations\r\n            if (findVectors) {\r\n              Rdiag[i] = multiplyScalar(Rdiag[i], f);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // return the diagonal row transformation matrix\r\n    return diag(Rdiag);\r\n  }\r\n\r\n  /**\r\n   * @param {number[][]} arr\r\n   * @param {number} N\r\n   * @param {number} prec\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @param {boolean} findVectors\r\n   * @param {number[][]} R the row transformation matrix that will be modified\r\n   */\r\n  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {\r\n    var big = type === 'BigNumber';\r\n    var cplx = type === 'Complex';\r\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\r\n    if (big) {\r\n      prec = bignumber(prec);\r\n    }\r\n    for (var i = 0; i < N - 2; i++) {\r\n      // Find the largest subdiag element in the i-th col\r\n\r\n      var maxIndex = 0;\r\n      var max = zero;\r\n      for (var j = i + 1; j < N; j++) {\r\n        var el = arr[j][i];\r\n        if (smaller(abs(max), abs(el))) {\r\n          max = el;\r\n          maxIndex = j;\r\n        }\r\n      }\r\n\r\n      // This col is pivoted, no need to do anything\r\n      if (smaller(abs(max), prec)) {\r\n        continue;\r\n      }\r\n      if (maxIndex !== i + 1) {\r\n        // Interchange maxIndex-th and (i+1)-th row\r\n        var tmp1 = arr[maxIndex];\r\n        arr[maxIndex] = arr[i + 1];\r\n        arr[i + 1] = tmp1;\r\n\r\n        // Interchange maxIndex-th and (i+1)-th column\r\n        for (var _j2 = 0; _j2 < N; _j2++) {\r\n          var tmp2 = arr[_j2][maxIndex];\r\n          arr[_j2][maxIndex] = arr[_j2][i + 1];\r\n          arr[_j2][i + 1] = tmp2;\r\n        }\r\n\r\n        // keep track of transformations\r\n        if (findVectors) {\r\n          var tmp3 = R[maxIndex];\r\n          R[maxIndex] = R[i + 1];\r\n          R[i + 1] = tmp3;\r\n        }\r\n      }\r\n\r\n      // Reduce following rows and columns\r\n      for (var _j3 = i + 2; _j3 < N; _j3++) {\r\n        var n = divideScalar(arr[_j3][i], max);\r\n        if (n === 0) {\r\n          continue;\r\n        }\r\n\r\n        // from j-th row subtract n-times (i+1)th row\r\n        for (var k = 0; k < N; k++) {\r\n          arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));\r\n        }\r\n\r\n        // to (i+1)th column add n-times j-th column\r\n        for (var _k = 0; _k < N; _k++) {\r\n          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));\r\n        }\r\n\r\n        // keep track of transformations\r\n        if (findVectors) {\r\n          for (var _k2 = 0; _k2 < N; _k2++) {\r\n            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return R;\r\n  }\r\n\r\n  /**\r\n   * @returns {{values: values, C: Matrix}}\r\n   * @see Press, Wiliams: Numerical recipes in Fortran 77\r\n   * @see https://en.wikipedia.org/wiki/QR_algorithm\r\n   */\r\n  function iterateUntilTriangular(A, N, prec, type, findVectors) {\r\n    var big = type === 'BigNumber';\r\n    var cplx = type === 'Complex';\r\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\r\n    if (big) {\r\n      prec = bignumber(prec);\r\n    }\r\n\r\n    // The Francis Algorithm\r\n    // The core idea of this algorithm is that doing successive\r\n    // A' = Q⁺AQ transformations will eventually converge to block-\r\n    // upper-triangular with diagonal blocks either 1x1 or 2x2.\r\n    // The Q here is the one from the QR decomposition, A = QR.\r\n    // Since the eigenvalues of a block-upper-triangular matrix are\r\n    // the eigenvalues of its diagonal blocks and we know how to find\r\n    // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.\r\n\r\n    var arr = clone(A);\r\n\r\n    // the list of converged eigenvalues\r\n    var lambdas = [];\r\n\r\n    // size of arr, which will get smaller as eigenvalues converge\r\n    var n = N;\r\n\r\n    // the diagonal of the block-diagonal matrix that turns\r\n    // converged 2x2 matrices into upper triangular matrices\r\n    var Sdiag = [];\r\n\r\n    // N×N matrix describing the overall transformation done during the QR algorithm\r\n    var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined;\r\n\r\n    // n×n matrix describing the QR transformations done since last convergence\r\n    var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined;\r\n\r\n    // last eigenvalue converged before this many steps\r\n    var lastConvergenceBefore = 0;\r\n    while (lastConvergenceBefore <= 100) {\r\n      lastConvergenceBefore += 1;\r\n\r\n      // TODO if the convergence is slow, do something clever\r\n\r\n      // Perform the factorization\r\n\r\n      var k = 0; // TODO set close to an eigenvalue\r\n\r\n      for (var i = 0; i < n; i++) {\r\n        arr[i][i] = subtract(arr[i][i], k);\r\n      }\r\n\r\n      // TODO do an implicit QR transformation\r\n      var {\r\n        Q,\r\n        R\r\n      } = qr(arr);\r\n      arr = multiply(R, Q);\r\n      for (var _i = 0; _i < n; _i++) {\r\n        arr[_i][_i] = addScalar(arr[_i][_i], k);\r\n      }\r\n\r\n      // keep track of transformations\r\n      if (findVectors) {\r\n        Qpartial = multiply(Qpartial, Q);\r\n      }\r\n\r\n      // The rightmost diagonal element converged to an eigenvalue\r\n      if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {\r\n        lastConvergenceBefore = 0;\r\n        lambdas.push(arr[n - 1][n - 1]);\r\n\r\n        // keep track of transformations\r\n        if (findVectors) {\r\n          Sdiag.unshift([[1]]);\r\n          inflateMatrix(Qpartial, N);\r\n          Qtotal = multiply(Qtotal, Qpartial);\r\n          if (n > 1) {\r\n            Qpartial = diag(Array(n - 1).fill(one));\r\n          }\r\n        }\r\n\r\n        // reduce the matrix size\r\n        n -= 1;\r\n        arr.pop();\r\n        for (var _i2 = 0; _i2 < n; _i2++) {\r\n          arr[_i2].pop();\r\n        }\r\n\r\n        // The rightmost diagonal 2x2 block converged\r\n      } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {\r\n        lastConvergenceBefore = 0;\r\n        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);\r\n        lambdas.push(...ll);\r\n\r\n        // keep track of transformations\r\n        if (findVectors) {\r\n          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));\r\n          inflateMatrix(Qpartial, N);\r\n          Qtotal = multiply(Qtotal, Qpartial);\r\n          if (n > 2) {\r\n            Qpartial = diag(Array(n - 2).fill(one));\r\n          }\r\n        }\r\n\r\n        // reduce the matrix size\r\n        n -= 2;\r\n        arr.pop();\r\n        arr.pop();\r\n        for (var _i3 = 0; _i3 < n; _i3++) {\r\n          arr[_i3].pop();\r\n          arr[_i3].pop();\r\n        }\r\n      }\r\n      if (n === 0) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // standard sorting\r\n    lambdas.sort((a, b) => +subtract(abs(a), abs(b)));\r\n\r\n    // the algorithm didn't converge\r\n    if (lastConvergenceBefore > 100) {\r\n      var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));\r\n      err.values = lambdas;\r\n      err.vectors = [];\r\n      throw err;\r\n    }\r\n\r\n    // combine the overall QR transformation Qtotal with the subsequent\r\n    // transformation S that turns the diagonal 2x2 blocks to upper triangular\r\n    var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;\r\n    return {\r\n      values: lambdas,\r\n      C\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @param {Matrix} A hessenberg-form matrix\r\n   * @param {number} N size of A\r\n   * @param {Matrix} C column transformation matrix that turns A into upper triangular\r\n   * @param {Matrix} R similarity that turns original matrix into A\r\n   * @param {number[]} values array of eigenvalues of A\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @returns {number[][]} eigenvalues\r\n   */\r\n  function findEigenvectors(A, N, C, R, values, prec, type) {\r\n    var Cinv = inv(C);\r\n    var U = multiply(Cinv, A, C);\r\n    var big = type === 'BigNumber';\r\n    var cplx = type === 'Complex';\r\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\r\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\r\n\r\n    // turn values into a kind of \"multiset\"\r\n    // this way it is easier to find eigenvectors\r\n    var uniqueValues = [];\r\n    var multiplicities = [];\r\n    for (var λ of values) {\r\n      var i = indexOf(uniqueValues, λ, equal);\r\n      if (i === -1) {\r\n        uniqueValues.push(λ);\r\n        multiplicities.push(1);\r\n      } else {\r\n        multiplicities[i] += 1;\r\n      }\r\n    }\r\n\r\n    // find eigenvectors by solving U − λE = 0\r\n    // TODO replace with an iterative eigenvector algorithm\r\n    // (this one might fail for imprecise eigenvalues)\r\n\r\n    var vectors = [];\r\n    var len = uniqueValues.length;\r\n    var b = Array(N).fill(zero);\r\n    var E = diag(Array(N).fill(one));\r\n\r\n    // eigenvalues for which usolve failed (due to numerical error)\r\n    var failedLambdas = [];\r\n    var _loop = function _loop() {\r\n      var λ = uniqueValues[_i4];\r\n      var S = subtract(U, multiply(λ, E)); // the characteristic matrix\r\n\r\n      var solutions = usolveAll(S, b);\r\n      solutions.shift(); // ignore the null vector\r\n\r\n      // looks like we missed something, try inverse iteration\r\n      while (solutions.length < multiplicities[_i4]) {\r\n        var approxVec = inverseIterate(S, N, solutions, prec, type);\r\n        if (approxVec == null) {\r\n          // no more vectors were found\r\n          failedLambdas.push(λ);\r\n          break;\r\n        }\r\n        solutions.push(approxVec);\r\n      }\r\n\r\n      // Transform back into original array coordinates\r\n      var correction = multiply(inv(R), C);\r\n      solutions = solutions.map(v => multiply(correction, v));\r\n      vectors.push(...solutions.map(v => flatten(v)));\r\n    };\r\n    for (var _i4 = 0; _i4 < len; _i4++) {\r\n      _loop();\r\n    }\r\n    if (failedLambdas.length !== 0) {\r\n      var err = new Error('Failed to find eigenvectors for the following eigenvalues: ' + failedLambdas.join(', '));\r\n      err.values = values;\r\n      err.vectors = vectors;\r\n      throw err;\r\n    }\r\n    return vectors;\r\n  }\r\n\r\n  /**\r\n   * Compute the eigenvalues of an 2x2 matrix\r\n   * @return {[number,number]}\r\n   */\r\n  function eigenvalues2x2(a, b, c, d) {\r\n    // λ± = ½ trA ± ½ √( tr²A - 4 detA )\r\n    var trA = addScalar(a, d);\r\n    var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));\r\n    var x = multiplyScalar(trA, 0.5);\r\n    var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);\r\n    return [addScalar(x, y), subtract(x, y)];\r\n  }\r\n\r\n  /**\r\n   * For an 2x2 matrix compute the transformation matrix S,\r\n   * so that SAS⁻¹ is an upper triangular matrix\r\n   * @return {[[number,number],[number,number]]}\r\n   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf\r\n   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\r\n   */\r\n  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {\r\n    var big = type === 'BigNumber';\r\n    var cplx = type === 'Complex';\r\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\r\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\r\n\r\n    // matrix is already upper triangular\r\n    // return an identity matrix\r\n    if (smaller(abs(c), prec)) {\r\n      return [[one, zero], [zero, one]];\r\n    }\r\n\r\n    // matrix is diagonalizable\r\n    // return its eigenvectors as columns\r\n    if (larger(abs(subtract(l1, l2)), prec)) {\r\n      return [[subtract(l1, d), subtract(l2, d)], [c, c]];\r\n    }\r\n\r\n    // matrix is not diagonalizable\r\n    // compute off-diagonal elements of N = A - λI\r\n    // N₁₂ = 0 ⇒ S = ( N⃗₁, I⃗₁ )\r\n    // N₁₂ ≠ 0 ⇒ S = ( N⃗₂, I⃗₂ )\r\n\r\n    var na = subtract(a, l1);\r\n    var nb = subtract(b, l1);\r\n    var nc = subtract(c, l1);\r\n    var nd = subtract(d, l1);\r\n    if (smaller(abs(nb), prec)) {\r\n      return [[na, one], [nc, zero]];\r\n    } else {\r\n      return [[nb, zero], [nd, one]];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enlarge the matrix from n×n to N×N, setting the new\r\n   * elements to 1 on diagonal and 0 elsewhere\r\n   */\r\n  function inflateMatrix(arr, N) {\r\n    // add columns\r\n    for (var i = 0; i < arr.length; i++) {\r\n      arr[i].push(...Array(N - arr[i].length).fill(0));\r\n    }\r\n\r\n    // add rows\r\n    for (var _i5 = arr.length; _i5 < N; _i5++) {\r\n      arr.push(Array(N).fill(0));\r\n      arr[_i5][_i5] = 1;\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  /**\r\n   * Create a block-diagonal matrix with the given square matrices on the diagonal\r\n   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal\r\n   * @param {number} N the size of the resulting matrix\r\n   */\r\n  function blockDiag(arr, N) {\r\n    var M = [];\r\n    for (var i = 0; i < N; i++) {\r\n      M[i] = Array(N).fill(0);\r\n    }\r\n    var I = 0;\r\n    for (var sub of arr) {\r\n      var n = sub.length;\r\n      for (var _i6 = 0; _i6 < n; _i6++) {\r\n        for (var j = 0; j < n; j++) {\r\n          M[I + _i6][I + j] = sub[_i6][j];\r\n        }\r\n      }\r\n      I += n;\r\n    }\r\n    return M;\r\n  }\r\n\r\n  /**\r\n   * Finds the index of an element in an array using a custom equality function\r\n   * @template T\r\n   * @param {Array<T>} arr array in which to search\r\n   * @param {T} el the element to find\r\n   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`\r\n   * @returns {number} the index of `el`, or -1 when it's not in `arr`\r\n   */\r\n  function indexOf(arr, el, fn) {\r\n    for (var i = 0; i < arr.length; i++) {\r\n      if (fn(arr[i], el)) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Provided a near-singular upper-triangular matrix A and a list of vectors,\r\n   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal\r\n   * to each vector in the list\r\n   * @template T\r\n   * @param {T[][]} A near-singular square matrix\r\n   * @param {number} N dimension\r\n   * @param {T[][]} orthog list of vectors\r\n   * @param {number} prec epsilon\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @return {T[] | null} eigenvector\r\n   *\r\n   * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration\r\n   */\r\n  function inverseIterate(A, N, orthog, prec, type) {\r\n    var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;\r\n    var b; // the vector\r\n\r\n    // you better choose a random vector before I count to five\r\n    var i = 0;\r\n    while (true) {\r\n      b = randomOrthogonalVector(N, orthog, type);\r\n      b = usolve(A, b);\r\n      if (larger(norm(b), largeNum)) {\r\n        break;\r\n      }\r\n      if (++i >= 5) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // you better converge before I count to ten\r\n    i = 0;\r\n    while (true) {\r\n      var c = usolve(A, b);\r\n      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {\r\n        break;\r\n      }\r\n      if (++i >= 10) {\r\n        return null;\r\n      }\r\n      b = normalize(c);\r\n    }\r\n    return b;\r\n  }\r\n\r\n  /**\r\n   * Generates a random unit vector of dimension N, orthogonal to each vector in the list\r\n   * @template T\r\n   * @param {number} N dimension\r\n   * @param {T[][]} orthog list of vectors\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @returns {T[]} random vector\r\n   */\r\n  function randomOrthogonalVector(N, orthog, type) {\r\n    var big = type === 'BigNumber';\r\n    var cplx = type === 'Complex';\r\n\r\n    // generate random vector with the correct type\r\n    var v = Array(N).fill(0).map(_ => 2 * Math.random() - 1);\r\n    if (big) {\r\n      v = v.map(n => bignumber(n));\r\n    }\r\n    if (cplx) {\r\n      v = v.map(n => complex(n));\r\n    }\r\n\r\n    // project to orthogonal complement\r\n    v = orthogonalComplement(v, orthog);\r\n\r\n    // normalize\r\n    return normalize(v, type);\r\n  }\r\n\r\n  /**\r\n   * Project vector v to the orthogonal complement of an array of vectors\r\n   */\r\n  function orthogonalComplement(v, orthog) {\r\n    for (var w of orthog) {\r\n      // v := v − (w, v)/∥w∥² w\r\n      v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));\r\n    }\r\n    return v;\r\n  }\r\n\r\n  /**\r\n   * Calculate the norm of a vector.\r\n   * We can't use math.norm because factory can't handle circular dependency.\r\n   * Seriously, I'm really fed up with factory.\r\n   */\r\n  function norm(v) {\r\n    return abs(sqrt(dot(v, v)));\r\n  }\r\n\r\n  /**\r\n   * Normalize a vector\r\n   * @template T\r\n   * @param {T[]} v\r\n   * @param {'number'|'BigNumber'|'Complex'} type\r\n   * @returns {T[]} normalized vec\r\n   */\r\n  function normalize(v, type) {\r\n    var big = type === 'BigNumber';\r\n    var cplx = type === 'Complex';\r\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\r\n    return multiply(divideScalar(one, norm(v)), v);\r\n  }\r\n  return complexEigs;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}